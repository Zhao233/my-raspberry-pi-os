# 笔记

## makefile
1. Makefile 中:= ?= += =的区别
= 是最基本的赋值
:= 是覆盖之前的值
?= 是如果没有被赋值过就赋予等号后面的值
+= 是添加等号后面的值

2. wildcard : 扩展通配符
例子：$(wildcard *.c) 来获取工作目录下的所有的.c文件列表

3. makefile变量替换
+ 替换字符串的后缀
    ``` c
    src := acc bcc dcc
    obj := $(src:cc=oo)
    test:
        @echo "obj => $(obj)"
    ```
    src: 需要替换的变量; cc: 需要替换的后缀; oo: 替换的后缀

+ patsubst ：替换通配符
    ``` c
    dir= a.c b.c c.c
    obj=$(patsubst %.c,%.o,$(dir))
    test:
        @echo "obj => $(obj)" 
    ```
    将dir中所有的.c 换为.o

+ 检索依赖
1. $^:      
所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。      
2. \$@       
表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，"$@"就是匹配于目标中模式定义的集合
3. $?       
所有比目标新的依赖目标的集合。以空格分隔。
4. \$<  
依赖目标中的第一个目标名字。如果依赖目标是以模式（即"%"）定义的，那么"$<"将是符合模式的一系列的文件集。注意，其是一个一个取出来的。
5. \$\(\@D)    
表示"$@"的目录部分（不以斜杠作为结尾） ，如果"$@"值是"dir/foo.o"，那么"$(@D)"就是"dir"，而如果"$@"中没有包含斜杠的话，其值就是"."（当前目录） 。
6. \$(@F)    
表示"$@"的文件部分，如果"$@"值是"dir/foo.o"，那么"$(@F)"就是"foo.o"，"$(@F)"相当于函数"$(notdir $@)"